// Generated by dts-bundle v0.7.3

declare module 'class-json' {
    export { Json } from 'class-json/Json';
    export { Rule } from 'class-json/validation/Rule';
    export { JsonConvert } from 'class-json/JsonConvert';
    export { JsonValidate } from 'class-json/JsonValidate';
    export { Serializable } from 'class-json/Serializable';
    export { JsonSettings } from 'class-json/JsonSettings';
    export { JsonUtils } from 'class-json/JsonUtils';
    export { JsonSchema } from 'class-json/JsonSchema';
}

declare module 'class-json/Json' {
    import { IJsonConverter } from 'class-json/IJsonConverter';
    import { IConstructor, IFunction } from 'class-json/JsonSettings';
    import { ModelInfo } from 'class-json/ModelInfo';
    export namespace Json {
        function ignore(): (target: any, propertyKey: any, descriptor?: any) => any;
        function name(name: any): (target: any, propertyKey: any, descriptor?: any) => any;
        function type(Ctor: IConstructor | IFunction, options?: any): (target: any, propertyKey: any, descriptor?: any) => any;
        function array(Ctor: IConstructor | IFunction, options?: any): (target: any, propertyKey: any, descriptor?: any) => any;
        function value(mix: any): (target: any, propertyKey: any, descriptor?: any) => any;
        function defaultValue(mix: any): (target: any, propertyKey: any, descriptor?: any) => any;
        function converter(Converter: Partial<IJsonConverter>): (target: any, propertyKey: any, descriptor?: any) => any;
        function description(text: string): (target: any, propertyKey?: any, descriptor?: any) => any;
        function meta<T = any>(meta: Partial<ModelInfo<T>>): (target: any, propertyKey?: any, descriptor?: any) => any;
        function stringify(): (target: any, propertyKey: any, descriptor?: any) => any;
    }
}

declare module 'class-json/validation/Rule' {
    import { IRuleInfo } from 'class-json/validation/RuleBase';
    import { PropertyInfo } from 'class-json/PropertyInfo';
    export namespace Rule {
        function required(message?: string): any;
        function required(opts?: IRuleInfo): any;
        function minLength(count: number, message?: string): any;
        function minLength(count: number, opts?: IRuleInfo): any;
        function maxLength(count: number, message?: string): any;
        function maxLength(count: number, opts?: IRuleInfo): any;
        function minimum(val: number, message?: string): any;
        function minimum(val: number, opts?: IRuleInfo): any;
        function maximum(val: number, message?: string): any;
        function maximum(val: number, opts?: IRuleInfo): any;
        function pattern(pattern: string | RegExp, message?: string): any;
        function pattern(pattern: string | RegExp, opts?: IRuleInfo): any;
        function stringEnum(values: string[], message?: string): any;
        function stringEnum(values: string[], opts?: IRuleInfo): any;
        function validate(fn: (val: any, root: any) => string, name?: string): (target: any, propertyKey: any, descriptor?: any) => any;
    }
    export namespace RuleUtil {
        function unboxRules(props: {
            [name: string]: PropertyInfo;
        }): void;
    }
}

declare module 'class-json/JsonConvert' {
    import { JsonSettings, IType } from 'class-json/JsonSettings';
    import { IJsonConverter } from 'class-json/IJsonConverter';
    export namespace JsonConvert {
        function toJson(model: any, settings?: JsonSettings): any;
        function toJSON(model: any, settings?: JsonSettings & IType): any;
        function fromJson(model: any, settings?: JsonSettings): any;
        function fromJSON<T = any>(json: any, settings?: JsonSettings & IType): T;
        function stringify(instance: any, settings?: JsonSettings): string;
        function parse<T = any>(str: string, settings?: JsonSettings): T;
    }
    export const JsonConverters: IJsonConverter[];
}

declare module 'class-json/JsonValidate' {
    import { IRuleError } from 'class-json/validation/IRule';
    export interface IValidationSettings<T = any> {
        mustValidate?: boolean;
        Type?: new (...args: any[]) => T;
    }
    export namespace JsonValidate {
        function validate<T>(model: T, settings?: IValidationSettings): IRuleError[];
        function validateProperty<T>(model: T, key: keyof T, settings?: IValidationSettings): IRuleError[];
    }
}

declare module 'class-json/Serializable' {
    import { IRuleError } from 'class-json/validation/IRule'; 
     import { JsonSettings, IType } from 'class-json/JsonSettings';
    import { IValidationSettings } from 'class-json/JsonValidate';
    type DeepPartial<T> = {
            [key in keyof T]?: T[key] extends object ? DeepPartial<T[key]> : T[key];
    };
    export class Serializable<T> {
            constructor(partial?: DeepPartial<T>);
            static fromJson<T extends typeof Serializable>(this: T, json: any, settings?: JsonSettings & IType): InstanceType<T>;
            static fromJSON<T extends typeof Serializable>(this: T, json: any, settings?: JsonSettings & IType): InstanceType<T>;
            static validate(x: any, settings?: IValidationSettings): IRuleError<any>[];
            toJson(settings?: JsonSettings): any;
            toJSON(settings?: JsonSettings): any;
            assign(partial?: Partial<T>): this;
    }
    export {};
}

declare module 'class-json/JsonSettings' {
    export interface JsonSettings {
        propertyResolver?: 'camelCase' | 'underScore';
        space?: number | string;
    }
    export interface IType {
        Type?: IConstructor | IFunction;
    }
    export interface IConstructor {
        new (...args: any[]): any;
    }
    export interface IFunction {
        (...args: any[]): any;
    }
}

declare module 'class-json/JsonUtils' {
    import { ModelInfo } from "class-json/ModelInfo";
    import { PropertyInfo } from "class-json/PropertyInfo";
    import { IRule } from 'class-json/validation/IRule';
    import { obj_map } from 'class-json/utils/obj';
    export namespace JsonUtils {
        const META_KEY = "__json__";
        function resolveModelMeta<TAdditional = void>(mix: object | Function): ModelInfo & TAdditional;
        function pickModelMeta<TAdditional = {}>(mix: any | Function): ModelInfo & TAdditional;
        function hasModelMeta(mix: object | Function): boolean;
        function pickPropertyMeta<TAdditional = void>(target: object | Function, propertyKey: string): PropertyInfo & TAdditional;
        function resolvePropertyMeta<TAdditional = void>(target: object | Function, propertyKey: string): PropertyInfo & TAdditional;
        function pickPropertyRules(target: object | Function, propertyKey: string): IRule[];
        function resolvePropertyRules(target: object | Function, propertyKey: string): IRule[];
        const map: typeof obj_map;
    }
}

declare module 'class-json/JsonSchema' {
    export interface IJsonSchemaBase {
        type: 'string' | 'number' | 'integer' | 'boolean' | 'object' | 'array' | 'any';
        title?: string;
        description?: string;
        default?: any;
        validation?: any;
    }
    export interface IJsonSchemaString {
        pattern?: string;
        format?: 'date-time' | 'time' | 'date' | 'email' | 'ipv4' | 'ipv6' | 'regex' | 'uri';
        enum?: (string | number)[];
        minLength?: number;
        maxLength?: number;
    }
    export interface IJsonSchemaNumber {
        minimum?: number;
        maximum?: number;
    }
    export interface IJsonSchemaBoolean {
    }
    export interface IJsonSchemaObject {
        properties?: {
            [key: string]: ISchema;
        };
        required?: string[];
    }
    export interface IJsonSchemaArray {
        items?: ISchema;
    }
    export type ISchema = IJsonSchemaBase & IJsonSchemaString & IJsonSchemaNumber & IJsonSchemaBoolean & IJsonSchemaObject & IJsonSchemaArray;
    export namespace JsonSchema {
        function getSchema(Type: any, schema?: Partial<ISchema>): ISchema;
    }
}

declare module 'class-json/IJsonConverter' {
    import { JsonSettings } from 'class-json/JsonSettings';
    export interface IJsonConverter {
        supports(val: any, type?: Function): boolean;
        fromJSON(jsonValue: any, settings?: JsonSettings): any;
        toJSON(instanceValue: any, settings?: JsonSettings): any;
    }
}

declare module 'class-json/ModelInfo' {
    import { PropertyInfo } from 'class-json/PropertyInfo';
    export interface ModelInfo<T = any> {
        description?: string;
        Type: new (...args: any[]) => T;
        nameMappings: {
            [jsonKey: string]: PropertyInfo;
        };
        properties: {
            [name in keyof T]: PropertyInfo;
        };
        defaults: {
            [name in keyof T]: any;
        };
    }
}

declare module 'class-json/validation/RuleBase' {
    import { IRule, IRuleError } from 'class-json/validation/IRule';
    export type TRuleInfo = string | IRuleInfo;
    export interface IRuleInfo {
        message?: string | ((prop: string, value: any, model: any) => string);
    }
    export abstract class RuleBase<T = any> implements IRule<T> {
        property: string;
        opts: IRuleInfo;
        constructor(property: string);
        constructor(property: string, opts: IRuleInfo);
        constructor(property: string, message: string);
        abstract validate(value: any, root: any): IRuleError<T>;
        formatMessage(value: any, root: any, $default: string): string;
    }
}

declare module 'class-json/PropertyInfo' {
    import { IJsonConverter } from 'class-json/IJsonConverter';
    import { IRule } from 'class-json/validation/IRule';
    import { IConstructor, IFunction } from 'class-json/JsonSettings';
    import { ModelInfo } from 'class-json/ModelInfo';
    export interface PropertyInfo {
        description?: string;
        property?: string;
        jsonIgnore?: boolean;
        jsonName?: string;
        Type?: IConstructor | IFunction;
        Meta?: ModelInfo;
        ArrayType?: IConstructor | IFunction;
        MapType?: Function;
        Converter?: Partial<IJsonConverter>;
        rules?: IRule[];
        default?: any;
        options?: any;
    }
}

declare module 'class-json/validation/IRule' {
    export interface IRule<T = any> {
        validate(value: any, root: any): IRuleError<T>;
    }
    export interface IRuleError<T = any> {
        name: string;
        property: string;
        value: T;
        message: string;
    }
}

declare module 'class-json/utils/obj' {
    export function obj_clone<T>(source: T): T;
    export function obj_getKeys(x: any): string[];
    export function obj_getProperty(obj_: any, path: string): any;
    export function obj_map<T extends object, TOut = any>(source: T | T[], mapper: IMapper<T>): any;
    export interface IMapper<T> {
        ignore?: boolean;
        exclude?: (keyof T)[];
        include?: (keyof T)[];
        props?: {
            [key in keyof T]?: IPropMapper<T[key]>;
        };
    }
    export interface IPropMapper<T> extends IMapper<T> {
        ignore?: boolean;
        name?: string;
        map?(x: T): any;
    }
}

