// Generated by dts-bundle v0.7.3

declare module 'class-json' {
    export { Json } from 'class-json/Json';
    export { Rule } from 'class-json/validation/Rule';
    export { JsonConvert } from 'class-json/JsonConvert';
    export { JsonValidate } from 'class-json/JsonValidate';
    export { Serializable } from 'class-json/Serializable';
    export { JsonSettings } from 'class-json/JsonSettings';
    export { JsonUtils } from 'class-json/JsonUtils';
}

declare module 'class-json/Json' {
    import { IJsonConverter } from 'class-json/IJsonConverter';
    export namespace Json {
        function ignore(): (target: any, propertyKey: any, descriptor?: any) => any;
        function name(name: any): (target: any, propertyKey: any, descriptor?: any) => any;
        function type(Ctor: Function, options?: any): (target: any, propertyKey: any, descriptor?: any) => any;
        function array(Ctor: Function, options?: any): (target: any, propertyKey: any, descriptor?: any) => any;
        function value(mix: any): (target: any, propertyKey: any, descriptor?: any) => any;
        function converter(Converter: Partial<IJsonConverter>): (target: any, propertyKey: any, descriptor?: any) => any;
        function stringify(): (target: any, propertyKey: any, descriptor?: any) => any;
    }
}

declare module 'class-json/validation/Rule' {
    export namespace Rule {
        function required(): (target: any, propertyKey: any, descriptor?: any) => any;
        function minLength(count: number): (target: any, propertyKey: any, descriptor?: any) => any;
        function maxLength(count: number): (target: any, propertyKey: any, descriptor?: any) => any;
        function pattern(pattern: string | RegExp): (target: any, propertyKey: any, descriptor?: any) => any;
        function validate(fn: (val: any, root: any) => string, name?: string): (target: any, propertyKey: any, descriptor?: any) => any;
    }
}

declare module 'class-json/JsonConvert' {
    import { JsonSettings } from 'class-json/JsonSettings';
    import { IJsonConverter } from 'class-json/IJsonConverter';
    export namespace JsonConvert {
        function toJson(model: any, settings?: JsonSettings): any;
        function fromJson<T>(json: any, settings?: JsonSettings): any;
    }
    export const JsonConverters: IJsonConverter[];
}

declare module 'class-json/JsonValidate' {
    import { IRuleError } from 'class-json/validation/IRule';
    export interface IValidationSettings<T = any> {
        Type?: new (...args: any[]) => T;
    }
    export namespace JsonValidate {
        function validate(model: any, settings?: IValidationSettings): IRuleError[];
    }
}

declare module 'class-json/Serializable' {
    import { IRuleError } from 'class-json/validation/IRule'; 
     import { JsonSettings } from 'class-json/JsonSettings';
    import { IValidationSettings } from 'class-json/JsonValidate';
    export class Serializable<T> {
            constructor(partial?: Partial<T>);
            static fromJson(json: any, settings?: JsonSettings): any;
            static fromJSON(json: any, settings?: JsonSettings): any;
            static validate(x: any, settings?: IValidationSettings): IRuleError<any>[];
            toJson(settings?: JsonSettings): any;
            toJSON(settings?: JsonSettings): any;
            assign(partial?: Partial<T>): this;
    }
}

declare module 'class-json/JsonSettings' {
    export interface JsonSettings {
        propertyResolver?: 'camelCase' | 'underScore';
        Type?: new (...args: any[]) => any;
    }
}

declare module 'class-json/JsonUtils' {
    import { ModelInfo } from "class-json/ModelInfo";
    import { PropertyInfo } from "class-json/PropertyInfo";
    import { IRule } from 'class-json/validation/IRule';
    export namespace JsonUtils {
        const META_KEY = "__json__";
        function resolveModelMeta<TAdditional = void>(mix: object | Function): ModelInfo & TAdditional;
        function pickModelMeta<TAdditional = void>(mix: object | Function): ModelInfo & TAdditional;
        function hasModelMeta(mix: object | Function): boolean;
        function pickPropertyMeta<TAdditional = void>(target: object | Function, propertyKey: string): PropertyInfo & TAdditional;
        function resolvePropertyMeta<TAdditional = void>(target: object | Function, propertyKey: string): PropertyInfo & TAdditional;
        function pickPropertyRules(target: object | Function, propertyKey: string): IRule[];
        function resolvePropertyRules(target: object | Function, propertyKey: string): IRule[];
    }
}

declare module 'class-json/IJsonConverter' {
    import { JsonSettings } from 'class-json/JsonSettings';
    import { PropertyInfo } from "class-json/PropertyInfo";
    export interface IJsonConverter {
        supports(val: any, type?: Function): boolean;
        fromJson(jsonValue: any, info?: PropertyInfo, settings?: JsonSettings): any;
        toJson(instanceValue: any, info?: PropertyInfo, settings?: JsonSettings): any;
    }
}

declare module 'class-json/validation/IRule' {
    export interface IRule<T = any> {
        validate(value: any, root: any): IRuleError<T>;
    }
    export interface IRuleError<T = any> {
        name: string;
        property: string;
        value: T;
        message: string;
    }
}

declare module 'class-json/ModelInfo' {
    import { PropertyInfo } from 'class-json/PropertyInfo';
    export interface ModelInfo<T = any> {
        Type: new (...args: any[]) => T;
        properties: {
            [name in keyof T]: PropertyInfo;
        };
        defaults: {
            [name in keyof T]: any;
        };
    }
}

declare module 'class-json/PropertyInfo' {
    import { IJsonConverter } from 'class-json/IJsonConverter';
    import { IRule } from 'class-json/validation/IRule';
    export interface PropertyInfo {
        property?: string;
        jsonIgnore?: boolean;
        jsonName?: string;
        Type?: Function;
        ArrayType?: Function;
        MapType?: Function;
        Converter?: Partial<IJsonConverter>;
        rules?: IRule[];
        options?: any;
    }
}

